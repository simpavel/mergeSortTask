    В папке test есть заготовки для проверки различных типов сортировки в соответствии с заданием:

          чисел по возрастанию - с именем in[i].txt
входные аргументы для них:
-a -i test\\out.txt test\\in1.txt test\\in2.txt test\\in3.txt test\\in4.txt test\\in5.txt

          чисел по убыванию - с именем in[i]reverse.txt
входные аргументы для них:     -
d -i test\\out.txt test\\in1reverse.txt test\\in2reverse.txt test\\in3reverse.txt test\\in4reverse.txt test\\in5reverse.txt

          строк по возрастанию - c именем in[i]str.txt
входные аргументы для них:
-a -s test\\out.txt test\\in1str.txt test\\in2str.txt test\\in3str.txt test\\in4str.txt test\\in5str.txt

          строк по убыванию - с именем in[i]strreverse.txt
входные аргументы для них:
-d -i test\\out.txt test\\in1strreverse.txt test\\in2strreverse.txt test\\in3strreverse.txt test\\in4strreverse.txt test\\in5strreverse.txt

          имя выходного файла - out.txt

          имя log-файла - LogFile.txt


C:\\Users\\nezt\\Desktop\\bigToSort\\in4.txt

     Заметки:
     1) Я мог бы использовать PriorityQueue с peek() и poll() для решения этой задачи (PriorityQueue была бы вместо
        массива, в который я записываю Scanner или BufferedReader. Я посчитал, что это будет не совсем "честно" для решения
        этой задачи
     2) Я попробовал провести имитацию слияния файлов, которые не помещаются в оперативную память. В качестве считывателя
        выступали Scanner либо BufferedReader (у него буффер в 8KB, у сканнера - 1KB). Проводил слияние файлов (один из которых
        был ~200 MB) с разными настройками Maximum Heap Size. Получилось, что оба варианта работало как при 256MB heap size,
        так и при 2GB. Программа выполнялась за ~24 секунды для Scanner и за ~19 секунд для BufferedReader. Поэтому остановился
        на нём.
      3) в заднии написано  Считается, что файлы предварительно отсортированы. Результатом работы программы должен являться новый файл с объединенным содержимым
         входных файлов, отсортированным по возрастанию или убыванию путем сортировки слиянием.
         Это можно интерпретировать двумя способами: либо входной файл отсортирован по возрастанию, либо по убыванию
         В нашей задаче предположим, что все входные файлы отсортированы по возрастанию (и если нам требуется совершить
         сортировку по убыванию, мы эти файлы читаем с конца).
         4) запретили использование чисел


        Вопросы:
     1) не совсем понимаю, что мне делать с исключениями? сделать так, чтобы методы на кидали их, а вместо этого
     сделать им try-catch и в логгер записывать?
     2) почему написано в задании (в самом низу), что запуск проводится через .exe ? у нас это будет .java или .class же?
     3) то что я сделал Это всё-таки Merge Sort?
     Ко мне закрадываются сомнения, что это слияние файлов нельзя назвать K-way External Merge Sort (на картинках у сортировки слиянием все данные разбиваются на одиночные элементы
     и они сортируются сначала в массиве из двух элементов, из четырех итд. А у меня тут вроде файлы то уже "пред"отсортированные, поэтому вроде как мы
     уже ничего не должны разбивать, а только собирать их в единый файл
     почему все эти trim нужны
     4) compareTo в FileContentScanner - нормально его сделал? Получается, он может и строки и числа принимать. Вот я там все числа
     переводу в BigDecimal - насколько это правильно?
     5) Почему я везде должен использовать .trim() ? Видимо сканнер что-то читает типа начала строки. надо почитать
     6) compareTo в FileContentScanner - нормально его сделал? Получается, он может и строки и числа принимать. Вот я там все числа
     переводу в BigDecimal - насколько это правильно?
     7) Получилось, что моей программе всё равно на вид считываемых данных (числа или string)
     8) Файлы сделанные с помощью BufferedReader методов весят меньше, чем сканерные... тхт одинаковые -.-
      9) bufferedReader - убираем классы со сканнером, делаем bufferedReader. Почему файл через бридер весит меньше??

    Что я дорабатываю:
     1) я думаю, что можно попробовать сделать код не через сканнер, а bufferedreader, наверное, должно работать быстрее
     но может какие-то другие подводные камни будут;
     2) хочу подшаманить с указанием путей в аргументах программы
     3) scanner.useDelimiter("\\n"); пока делал, забыл, зачем поставил, надо перепроверить, по-моему, для сортировки строк с пробелами/
     4) переделать regEx для поиска пробелов в сканнерах, этот не ловит, если пробел внутри строки
     5) я заметил, что Windows notepad не видит мои \\n, а notepad++ видит. Хз, надо ли с этим что-то делать
     6) priorityqueue>
